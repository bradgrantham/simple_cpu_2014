%{

#include <vector>
#include <map>
#include <string>
#include <stdio.h>

#include "parsing.h"

#define YYERROR_VERBOSE

#ifdef DEBUG
bool debug = true;
#else
bool debug = false;
#endif
extern int curLine;
labels_map labels;
OutputFile file;
std::vector<Instruction::sptr> instructions;
std::vector<Store> stores;
int yylex();
void yyerror(const char *s);

typedef unsigned int uint;

namespace shift_type {
    const uint RL = 0x00;
    const uint RA = 0x01;
    const uint LL = 0x02;
    const uint LA = 0x03;
};

namespace opcode {
    const uint AND = 0x00;
    const uint OR = 0x01;
    const uint XOR = 0x02;
    const uint NOT = 0x03;
    const uint ADD = 0x04;
    const uint ADC = 0x05;
    const uint SUB = 0x06;
    const uint MULT = 0x07;
    const uint DIV = 0x08;
    const uint CMP = 0x09;
    const uint XCHG = 0x0a;

    const uint MOV = 0x0b;
    const uint LOAD = 0x0c;
    const uint STORE = 0x0d;
    const uint PUSH = 0x0e;
    const uint POP = 0x0f;

    const uint MOVIU = 0x10;
    const uint ADDI = 0x11;
    const uint ADDIU = 0x12;
    const uint CMPIU = 0x13;
    const uint SHIFT = 0x14;

    const uint JL = 0x15;
    const uint JNE = 0x16;
    const uint JR = 0x17;
    const uint JSR = 0x18;
    const uint RSR = 0x19;
    const uint JMP = 0x1a;

    const uint SYS = 0x1b;
    const uint SWAPCC = 0x1c;
    const uint UNUSED_1d = 0x1d;
    const uint UNUSED_1e = 0x1e;
    const uint HALT = 0x1f;
};

uint curAddress = 0;
std::vector<std::pair<uint, std::string> > labels_at_next_address;

void PadAddressAndAssignLabels(uint linenumber, uint& address, uint pad)
{
    address = (address + pad - 1) & (~(pad - 1));
    for(auto it = labels_at_next_address.begin(); it != labels_at_next_address.end(); it++) {
        if(labels.find(it->second) != labels.end()) {
            fprintf(stderr, "warning: label \"%s\" redefined at line %d\n", it->second.c_str(), it->first);
        }
        labels[it->second] = LineNumberExpr(ExprInt::sptr(new ExprInt(address)), it->first);
        if(debug) printf("label %s at line %d set to %08X by statement at line %d, \n", it->second.c_str(), it->first, address, linenumber);
    }
    labels_at_next_address.clear();
}

/* set expression list to store */
void SaveExpressions(uint line, uint& address, int size, ExprList* list)
{
    boost::shared_ptr<ExprList> exprs(list);
    stores.push_back(Store(line, address, size, *list));
    address += size * list->size();
}


%}

%union {
    int         i;
    struct ExprBase    *expr;
    ExprList    *exprlist;
    std::string *str;
}

%token COMMA
%token <i> HLT SWAPCC RSR PUSH POP JL JMP JNE SYS AND OR XOR NOT ADD ADC SUB MULT DIV CMP XCHG MOV MOVIU ADDIU ADDI CMPIU SHIFT JR JSR LOAD STORE
%token DOT_ORG DOT_DEFINE DOT_BYTE DOT_SHORT DOT_WORD DOT_STRING
%token DOT_RL DOT_RA DOT_LL DOT_LA
%token NEWLINE

%token <str> IDENTIFIER
%token <str> LABEL

%token <str> STRINGLITERAL
%token <i> INTEGER
%token <i> REGISTER

%type <i> shift_type
%type <i> size_modifier
%type <expr> expression
%type <exprlist> expression_list
%type <i> mnemonic_direct
%type <i> mnemonic_rx
%type <i> mnemonic_imm
%type <i> mnemonic_rxry
%type <i> mnemonic_rximm
%type <i> mnemonic_rximm_varied
%type <i> mnemonic_rxryimm_sized

%%

file :
          lines { StoreMemoryDirectives(labels, file, stores); StoreInstructions(labels, file, instructions); }
        ;
/* store memory directives, checking sizes, incrementing by address size */
/* go through instructions, evaluate data parameters, check size of data, store */

lines :
          line
        | lines line
        ;

line :
          instruction_line { curLine++; }
        | directive_line { curLine++; }
        | label_only_line { curLine++; }
        | empty_line { curLine++; }
        ;

instruction_line :
          label instruction NEWLINE { }
        | instruction NEWLINE { }
        ;

directive_line :
          label directive NEWLINE { }
        | directive NEWLINE { }
        ;

label_only_line :
          label NEWLINE { }
        ;

label :
          LABEL { labels_at_next_address.push_back(std::pair<uint, std::string>(curAddress, *$1)); delete $1; }
        ;

empty_line :
          NEWLINE
        ;

directive :
          org_directive { if(0)printf("org dir\n"); }
        | mem_directive { if(0)printf("mem dir\n"); }
        | string_directive { if(0)printf("string dir\n"); }
        | define_directive { if(0)printf("define dir\n"); }
        ;

instruction :
          instruction_direct { if(0)printf("instr direct\n"); }
        | instruction_imm { if(0)printf("instr imm\n"); }
        | instruction_rx { if(0)printf("instr rx\n"); }
        | instruction_rximm { if(0)printf("instr rximm\n"); }
        | instruction_rximm_varied { if(0)printf("instr rximm_varied\n"); }
        | instruction_rxry { if(0)printf("instr rxry\n"); }
        | instruction_rxryimm_sized { if(0)printf("instr rxryimm_sized\n"); }
        ;

org_directive :
          DOT_ORG INTEGER { curAddress = $2; printf("address set to %x\n", $2);}
        ;

define_directive :
          DOT_DEFINE IDENTIFIER expression { ExprBase::sptr e($3); labels[*$2] = LineNumberExpr(e, curLine); }
        ;
/* store an identifier with value number */

expression_list :
          expression { $$ = new ExprList; ExprBase::sptr e($1); $$->push_back(e); }
        | expression_list COMMA expression { $$ = $1; ExprBase::sptr e($3); $$->push_back(e); }
        ;
mem_directive :
          size_modifier expression_list { PadAddressAndAssignLabels(curLine, curAddress, $1); SaveExpressions(curLine, curAddress, $1, $2); }
        ;

string_directive :
          DOT_STRING STRINGLITERAL { PadAddressAndAssignLabels(curLine, curAddress, 1); printf("XXX string literal unhandled\n"); }
        ;
/* set any labels ; store string, incrementing address by size of string */


instruction_direct : 
          mnemonic_direct { PadAddressAndAssignLabels(curLine, curAddress, 4); Instruction::sptr ins(new InstructionDirect(curAddress, curLine, $1)); instructions.push_back(ins); curAddress += 4; }
        ;
mnemonic_direct : 
          HLT { $$ = opcode::HALT; }
        ;

instruction_rx :
          mnemonic_rx REGISTER { PadAddressAndAssignLabels(curLine, curAddress, 4); printf("rx instruction %d on register %d\n", $1, $2); }
        ;
mnemonic_rx :
          SWAPCC { $$ = opcode::SWAPCC; }
        | RSR { $$ = opcode::RSR; }
        | PUSH { $$ = opcode::PUSH; }
        | POP { $$ = opcode::POP; }
        ;

instruction_imm : mnemonic_imm expression { PadAddressAndAssignLabels(curLine, curAddress, 4); if(0)printf("imm\n"); }
        ;
mnemonic_imm :
          JL { $$ = opcode::JL; }
        | JMP { $$ = opcode::JMP; }
        | JNE { $$ = opcode::JNE; }
        | SYS { $$ = opcode::SYS; }
        ;

instruction_rxry :
          mnemonic_rxry REGISTER COMMA REGISTER { PadAddressAndAssignLabels(curLine, curAddress, 4); if(0)printf("rxry\n"); }
        ;
mnemonic_rxry :
          AND { $$ = opcode::AND; }
        | OR { $$ = opcode::OR; }
        | XOR { $$ = opcode::XOR; }
        | NOT { $$ = opcode::NOT; }
        | ADD { $$ = opcode::ADD; }
        | ADC { $$ = opcode::ADC; }
        | SUB { $$ = opcode::SUB; }
        | MULT { $$ = opcode::MULT; }
        | DIV { $$ = opcode::DIV; }
        | CMP { $$ = opcode::CMP; }
        | XCHG { $$ = opcode::XCHG; }
        | MOV { $$ = opcode::MOV; }
        ;

instruction_rximm :
          mnemonic_rximm REGISTER COMMA expression { PadAddressAndAssignLabels(curLine, curAddress, 4); if(0)printf("rximm\n"); }
        ;
mnemonic_rximm :
          MOVIU { $$ = opcode::MOVIU; }
        | ADDIU { $$ = opcode::ADDIU; }
        | ADDI { $$ = opcode::ADDI; }
        | CMPIU { $$ = opcode::CMPIU; }
        | JR { $$ = opcode::JR; }
        | JSR { $$ = opcode::JSR; }
        ;

instruction_rximm_varied :
          mnemonic_rximm_varied shift_type REGISTER COMMA expression { PadAddressAndAssignLabels(curLine, curAddress, 4); if(0)printf("instruction_rximm_varied\n"); }
        ;
mnemonic_rximm_varied :
          SHIFT { $$ = opcode::SHIFT; }
        ;
shift_type :
          DOT_LA { $$ = shift_type::LA; }
        | DOT_RA { $$ = shift_type::RA; }
        | DOT_LL { $$ = shift_type::LL; }
        | DOT_RL { $$ = shift_type::RL; }
        ;

instruction_rxryimm_sized :
          mnemonic_rxryimm_sized size_modifier REGISTER COMMA REGISTER { PadAddressAndAssignLabels(curLine, curAddress, 4); if(0)printf("instruction_rxryimm_size\n"); }
        ;
mnemonic_rxryimm_sized :
          LOAD { $$ = opcode::LOAD; }
        | STORE { $$ = opcode::STORE; }
        ;
size_modifier :
          DOT_BYTE { $$ = 1; }
        | DOT_SHORT { $$ = 2; }
        | DOT_WORD { $$ = 4; }
        ;
/* pad address to 4; set any labels ; store instruction to set later */

expression :
          INTEGER { $$ = new ExprInt($1); }
        | IDENTIFIER { $$ = new ExprIdent(*$1); delete $1; }
        ;

%%

extern FILE *yyin;

int main( int argc, char **argv )
{
    yyin = stdin;
    while(!feof(yyin)) {
        yyparse();
    }
}

void yyerror(const char *s)
{
    fprintf(stderr, "line %d: %s\n", curLine, s);
}
