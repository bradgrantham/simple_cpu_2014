%{

#include <vector>
#include <map>
#include <string>
#include <stdio.h>

#include "parsing.h"

#define YYERROR_VERBOSE

extern int curLine;
labels_map labels;
OutputFile file;
std::vector<Instruction::sptr> instructions;
int yylex();
void yyerror(const char *s);

typedef unsigned int uint;

namespace shift_type {
    const uint LA = 0x00;
    const uint RA = 0x01;
    const uint LL = 0x02;
    const uint RL = 0x03;
};

namespace opcode {
    const uint AND = 0x00;
    const uint OR = 0x01;
    const uint XOR = 0x02;
    const uint NOT = 0x03;
    const uint ADD = 0x04;
    const uint ADC = 0x05;
    const uint SUB = 0x06;
    const uint MULT = 0x07;
    const uint DIV = 0x08;
    const uint CMP = 0x09;
    const uint XCHG = 0x0a;

    const uint MOV = 0x0b;
    const uint LOAD = 0x0c;
    const uint STORE = 0x0d;
    const uint PUSH = 0x0e;
    const uint POP = 0x0f;

    const uint MOVIU = 0x10;
    const uint ADDI = 0x11;
    const uint ADDIU = 0x12;
    const uint CMPIU = 0x13;
    const uint SHIFT = 0x14;

    const uint JL = 0x15;
    const uint JNE = 0x16;
    const uint JR = 0x17;
    const uint JSR = 0x18;
    const uint RSR = 0x19;
    const uint JMP = 0x1a;

    const uint SYS = 0x1b;
    const uint SWAPCC = 0x1c;
    const uint UNUSED_1d = 0x1d;
    const uint UNUSED_1e = 0x1e;
    const uint HALT = 0x1f;
};

unsigned int curAddress = 0;
std::vector<std::string> labels_at_next_address;

%}

%union {
    int         i;
    struct ExprBase    *expr;
    ExprList    *exprlist;
    std::string *str;
}

%token COMMA
%token <i> HLT SWAPCC RSR PUSH POP JL JMP JNE SYS AND OR XOR NOT ADD ADC SUB MULT DIV CMP XCHG MOV MOVIU ADDIU ADDI CMPIU SHIFT JR JSR LOAD STORE
%token DOT_ORG DOT_DEFINE DOT_BYTE DOT_SHORT DOT_WORD DOT_STRING
%token DOT_RL DOT_RA DOT_LL DOT_LA
%token NEWLINE

%token <str> IDENTIFIER
%token <str> LABEL

%token <str> STRINGLITERAL
%token <i> INTEGER
%token <i> REGISTER

%type <i> shift_type
%type <i> size_modifier
%type <expr> expression
%type <exprlist> expression_list
%type <i> mnemonic_direct
%type <i> mnemonic_rx
%type <i> mnemonic_imm
%type <i> mnemonic_rxry
%type <i> mnemonic_rximm
%type <i> mnemonic_rximm_varied
%type <i> mnemonic_rxryimm_sized

%%

file :
          lines { StoreInstructions(file, instructions); }
        ;
/* recursively evaluate expressions */
/* store memory directives, checking sizes, incrementing by address size */
/* go through instructions, evaluate data parameters, check size of data, store */

lines :
          line 
        | lines line
        ;

line :
          instruction_line
        | directive_line
        | label_only_line
        | empty_line
        ;

instruction_line :
          label instruction NEWLINE { if(0)printf("label instr\n"); }
        | instruction NEWLINE { if(0)printf("instr alone\n"); }
        ;

directive_line :
          label directive NEWLINE { if(0)printf("label: dir\n"); }
        | directive NEWLINE { if(0)printf("dir alone\n"); }
        ;

label_only_line :
          label NEWLINE { if(0)printf("label only\n"); }
        ;

label :
          LABEL { labels_at_next_address.push_back(*$1); delete $1; }
        ;

empty_line :
          NEWLINE
        ;

directive :
          org_directive { if(0)printf("org dir\n"); }
        | mem_directive { if(0)printf("mem dir\n"); }
        | string_directive { if(0)printf("string dir\n"); }
        | define_directive { if(0)printf("define dir\n"); }
        ;

instruction :
          instruction_direct { if(0)printf("instr direct\n"); }
        | instruction_imm { if(0)printf("instr imm\n"); }
        | instruction_rx { if(0)printf("instr rx\n"); }
        | instruction_rximm { if(0)printf("instr rximm\n"); }
        | instruction_rximm_varied { if(0)printf("instr rximm_varied\n"); }
        | instruction_rxry { if(0)printf("instr rxry\n"); }
        | instruction_rxryimm_sized { if(0)printf("instr rxryimm_sized\n"); }
        ;

org_directive :
          DOT_ORG INTEGER { curAddress = $2; printf("address set to %x\n", $2);}
        ;

define_directive :
          DOT_DEFINE IDENTIFIER expression { ExprBase::sptr e($3); labels[*$2] = LineNumberExpr(e, curLine); }
        ;
/* store an identifier with value number */

expression_list :
          expression { $$ = new ExprList; $$->push_back($1); }
        | expression_list COMMA expression { $$ = $1; $$->push_back($3); }
        ;
mem_directive :
          size_modifier expression_list { if(0)printf("mem\n"); }
        ;
/* maybe pad address to size; set any labels; set expression list to store */

string_directive :
          DOT_STRING STRINGLITERAL { if(0)printf("string\n"); }
        ;
/* set any labels ; store string, incrementing address by size of string */


instruction_direct : 
          mnemonic_direct { Instruction::sptr ins(new InstructionDirect(curAddress, curLine, $1)); instructions.push_back(ins); }
        ;
mnemonic_direct : 
          HLT { $$ = opcode::HALT; }
        ;

instruction_rx :
          mnemonic_rx REGISTER { printf("rx instruction %d on register %d\n", $1, $2); }
        ;
mnemonic_rx :
          SWAPCC { $$ = opcode::SWAPCC; }
        | RSR { $$ = opcode::RSR; }
        | PUSH { $$ = opcode::PUSH; }
        | POP { $$ = opcode::POP; }
        ;

instruction_imm : mnemonic_imm expression { if(0)printf("imm\n"); }
        ;
mnemonic_imm :
          JL { $$ = opcode::JL; }
        | JMP { $$ = opcode::JMP; }
        | JNE { $$ = opcode::JNE; }
        | SYS { $$ = opcode::SYS; }
        ;

instruction_rxry :
          mnemonic_rxry REGISTER COMMA REGISTER { if(0)printf("rxry\n"); }
        ;
mnemonic_rxry :
          AND { $$ = opcode::AND; }
        | OR { $$ = opcode::OR; }
        | XOR { $$ = opcode::XOR; }
        | NOT { $$ = opcode::NOT; }
        | ADD { $$ = opcode::ADD; }
        | ADC { $$ = opcode::ADC; }
        | SUB { $$ = opcode::SUB; }
        | MULT { $$ = opcode::MULT; }
        | DIV { $$ = opcode::DIV; }
        | CMP { $$ = opcode::CMP; }
        | XCHG { $$ = opcode::XCHG; }
        | MOV { $$ = opcode::MOV; }
        ;

instruction_rximm :
          mnemonic_rximm REGISTER COMMA expression { if(0)printf("rximm\n"); }
        ;
mnemonic_rximm :
          MOVIU { $$ = opcode::MOVIU; }
        | ADDIU { $$ = opcode::ADDIU; }
        | ADDI { $$ = opcode::ADDI; }
        | CMPIU { $$ = opcode::CMPIU; }
        | JR { $$ = opcode::JR; }
        | JSR { $$ = opcode::JSR; }
        ;

instruction_rximm_varied :
          mnemonic_rximm_varied shift_type REGISTER COMMA expression { if(0)printf("instruction_rximm_varied\n"); }
        ;
mnemonic_rximm_varied :
          SHIFT { $$ = opcode::SHIFT; }
        ;
shift_type :
          DOT_LA { $$ = shift_type::LA; }
        | DOT_RA { $$ = shift_type::RA; }
        | DOT_LL { $$ = shift_type::LL; }
        | DOT_RL { $$ = shift_type::RL; }
        ;

instruction_rxryimm_sized :
          mnemonic_rxryimm_sized size_modifier REGISTER COMMA REGISTER { if(0)printf("instruction_rxryimm_size\n"); }
        ;
mnemonic_rxryimm_sized :
          LOAD { $$ = opcode::LOAD; }
        | STORE { $$ = opcode::STORE; }
        ;
size_modifier :
          DOT_BYTE { $$ = 1; }
        | DOT_SHORT { $$ = 2; }
        | DOT_WORD { $$ = 4; }
        ;
/* pad address to 4; set any labels ; store instruction to set later */

expression :
          INTEGER { $$ = new ExprInt($1); }
        | IDENTIFIER { $$ = new ExprIdent(*$1); delete $1; }
        ;

%%

extern FILE *yyin;

int main( int argc, char **argv )
{
    yyin = stdin;
    while(!feof(yyin)) {
        yyparse();
    }
}

void yyerror(const char *s)
{
    fprintf(stderr, "line %d: %s\n", curLine, s);
}
